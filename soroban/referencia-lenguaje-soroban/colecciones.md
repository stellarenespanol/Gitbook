# Colecciones

### üìö Colecciones

Las colecciones son estructuras de datos que te permiten almacenar y manipular m√∫ltiples valores. En Soroban, est√°n optimizadas para el entorno blockchain y difieren de las implementaciones est√°ndar de Rust.

* **Vec (soroban\_sdk::vec::Vec)**: Implementaci√≥n propia de Soroban para vectores din√°micos.
* **Map (soroban\_sdk::map::Map)**: Implementaci√≥n propia de Soroban para colecciones de pares clave-valor.

#### 1. Vec en Soroban üåü

El **Vec** en Soroban es una colecci√≥n din√°mica que permite almacenar una secuencia de elementos de un mismo tipo. Al igual que en Rust, su tama√±o puede crecer de forma din√°mica. En el contexto de Soroban se trabaja con √©l a trav√©s del entorno (env), lo que facilita su integraci√≥n en contratos inteligentes.

```rust
use soroban_sdk::{Env, Vec};

pub fn ejemplo_vec(env: &Env) {
    let mut numeros = Vec::new(env); // Crea un Vec vac√≠o
    numeros.push(10);
    numeros.push(20);
    // Puedes registrar el contenido usando el log del entorno
    env.log().info("Contenido del Vec:", numeros);
}
```

***

#### 2. Map en Soroban üîÑ

El **Map** en Soroban es una colecci√≥n de pares clave-valor, muy √∫til para asociar claves √∫nicas a valores, similar a un diccionario. Tambi√©n requiere el entorno (env) para su creaci√≥n y manipulaci√≥n, lo que lo hace ideal para el manejo de datos en contratos inteligentes.

```rust
use soroban_sdk::{Env, Map};

pub fn ejemplo_map(env: &Env) {
    let mut mi_mapa = Map::new(env); // Crea un Map vac√≠o
    mi_mapa.set(1, "uno");
    mi_mapa.set(2, "dos");
    // Registra el contenido del Map
    env.log().info("Contenido del Map:", mi_mapa);
}
```

**Contratos inteligentes ejemplo:**

Abrimos la consola en la ruta donde deseamos crear el proyecto y ejecutamos.

```bash
stellar contract init collections --name vecmap
```

Borramos todo el c√≥digo y ponemos lo siguiente:

```rust
#![no_std]
use soroban_sdk::{contract, contractimpl, symbol_short, Env, Map, String, Symbol, Vec};

#[contract]
pub struct VecMapContract;

#[contractimpl]
impl VecMapContract {
    const VEC_KEY: Symbol = symbol_short!("vec");
    const MAP_KEY: Symbol = symbol_short!("map");

    fn get_vec(env: &Env) -> Vec<String> {
        env.storage()
            .instance()
            .get(&Self::VEC_KEY)
            .unwrap_or(Vec::new(&env))
    }

    fn set_vec(env: &Env, vec: &Vec<String>) {
        env.storage().instance().set(&Self::VEC_KEY, vec);
    }

    // Funciones para manejo de Vec
    pub fn add_vec(env: Env, value: String) -> u32 {
        let mut my_vec: Vec<String> = Self::get_vec(&env);
        my_vec.push_back(value);
        Self::set_vec(&env, &my_vec);
        my_vec.len()
    }

    //Obtenemos un elemento del vector
    pub fn get_vec_element(env: Env, index: u32) -> Option<String> {
        let my_vec: Vec<String> = Self::get_vec(&env);
        my_vec.get(index)
    }

    pub fn remove_vec_element(env: Env, index: u32) -> Option<()> {
        let mut my_vec = Self::get_vec(&env);
        // Verificamos primero si el √≠ndice es v√°lido
        if my_vec.get(index).is_some() {
            let element: Option<()> = my_vec.remove(index);
            Self::set_vec(&env, &my_vec);
            Some(())
        } else {
            None
        }
    }

    fn get_map(env: &Env) -> Map<Symbol, String> {
        env.storage()
            .instance()
            .get(&Self::MAP_KEY)
            .unwrap_or(Map::new(env))
    }

    fn set_map(env: &Env, map: &Map<Symbol, String>) {
        env.storage().instance().set(&Self::MAP_KEY, map);
    }

    // Funciones para manejo de Map
    
    // Agregamos un elemento al map
    pub fn add_map_entry(env: Env, key: Symbol, value: String) {
        let mut my_map = Self::get_map(&env);
        my_map.set(key, value);
        Self::set_map(&env, &my_map);
    }
    //Obtener algun valor del map
    pub fn get_map_value(env: Env, key: Symbol) -> Option<String> {
        let my_map = Self::get_map(&env);
        my_map.get(key)
    }

    // Eliminar un elemento del map
    pub fn remove_map_entry(env: Env, key: Symbol) -> Option<()> {
        let env_ref = &env;
        let mut my_map = Self::get_map(env_ref);
        if my_map.remove(key).is_some() {
            Self::set_map(&env, &my_map);
            Some(()) // √âxito
        } else {
            None     // La clave no exist√≠a
        }
    }
}
```

## Explicaci√≥n del contrato

üìå **Estructuras y Tipos del Contrato**

**Atributo `#![no_std]`**\
Indica que el contrato no utiliza la biblioteca est√°ndar de Rust, lo cual es com√∫n en entornos embebidos o en contratos inteligentes para reducir dependencias y adaptarse a restricciones de recursos.

**Macros de Contrato**\
`#[contract]` y `#[contractimpl]`\
Estas macros son proporcionadas por el _soroban\_sdk_ y se usan para marcar:

* **`#[contract]`**: Define la estructura principal del contrato.
* **`#[contractimpl]`**: Implementa la l√≥gica de negocio del contrato.\
  Para m√°s detalles, consulta la documentaci√≥n de contratos Soroban en:\
  [Escribir Contratos en Soroban](https://soroban.stellar.org/docs/developers/writing-contracts)

**Constantes del Contrato**

* **`VEC_KEY`**: Clave (tipo `Symbol`) para almacenar y recuperar el vector (`Vec<String>`) en el storage.
* **`MAP_KEY`**: Clave (tipo `Symbol`) para almacenar y recuperar el mapa (`Map<Symbol, String>`) en el storage.

***

üõ† **Funciones del Contrato**

1Ô∏è‚É£ **get\_vec**

```rust
fn get_vec(env: &Env) -> Vec<String> {
    env.storage()
        .instance()
        .get(&Self::VEC_KEY)
        .unwrap_or(Vec::new(&env))
}
```

**Descripci√≥n:**\
Recupera el vector almacenado en el contrato. Si no existe, devuelve un vector vac√≠o.

**Mecanismo:**

* Accede al storage utilizando la clave `VEC_KEY`.
* Utiliza `unwrap_or` para devolver un `Vec` nuevo en caso de que no se encuentre ning√∫n valor.

***

2Ô∏è‚É£ **set\_vec**

```rust
fn set_vec(env: &Env, vec: &Vec<String>) {
    env.storage().instance().set(&Self::VEC_KEY, vec);
}
```

**Descripci√≥n:**\
Almacena el vector proporcionado en el storage del contrato, usando la clave `VEC_KEY`.

**Mecanismo:**

* Se guarda el `Vec` de cadenas en el storage para persistir los cambios.

***

3Ô∏è‚É£ **add\_vec**

```rust
pub fn add_vec(env: Env, value: String) -> u32 {
    let mut my_vec: Vec<String> = Self::get_vec(&env);
    my_vec.push_back(value);
    Self::set_vec(&env, &my_vec);
    my_vec.len()
}
```

**Descripci√≥n:**\
Agrega un elemento al final del vector y devuelve la nueva longitud del mismo.

**Mecanismo:**

* Recupera el vector actual mediante `get_vec`.
* Usa `push_back` para agregar el valor (tipo `String`).
* Actualiza el storage con el vector modificado mediante `set_vec`.
* Retorna la longitud del vector actualizado.

***

4Ô∏è‚É£ **get\_vec\_element**

```rust
pub fn get_vec_element(env: Env, index: u32) -> Option<String> {
    let my_vec: Vec<String> = Self::get_vec(&env);
    my_vec.get(index)
}
```

**Descripci√≥n:**\
Obtiene el elemento ubicado en el √≠ndice especificado del vector.\
Devuelve `Some(elemento)` si existe o `None` si el √≠ndice es inv√°lido.

**Mecanismo:**

* Recupera el vector desde el storage.
* Usa el m√©todo `get` para obtener el elemento en la posici√≥n indicada.

***

5Ô∏è‚É£ **remove\_vec\_element**

```rust
pub fn remove_vec_element(env: Env, index: u32) -> Option<()> {
    let mut my_vec = Self::get_vec(&env);
    if my_vec.get(index).is_some() {
        let element: Option<()> = my_vec.remove(index);
        Self::set_vec(&env, &my_vec);
        Some(())
    } else {
        None
    }
}
```

**Descripci√≥n:**\
Elimina el elemento en el √≠ndice indicado del vector.\
Retorna `Some(())` si la eliminaci√≥n fue exitosa o `None` si el √≠ndice no es v√°lido.

**Mecanismo:**

* Verifica si el √≠ndice es v√°lido utilizando `get`.
* Si existe el elemento, se elimina mediante `remove`.
* Se actualiza el vector en el storage usando `set_vec`.

***

6Ô∏è‚É£ **get\_map**

```rust
fn get_map(env: &Env) -> Map<Symbol, String> {
    env.storage()
        .instance()
        .get(&Self::MAP_KEY)
        .unwrap_or(Map::new(env))
}
```

**Descripci√≥n:**\
Recupera el mapa almacenado en el contrato.\
Si no existe, devuelve un mapa nuevo y vac√≠o.

**Mecanismo:**

* Accede al storage usando la clave `MAP_KEY`.
* Utiliza `unwrap_or` para retornar un `Map` vac√≠o si no se encuentra ning√∫n valor.

***

7Ô∏è‚É£ **set\_map**

```rust
fn set_map(env: &Env, map: &Map<Symbol, String>) {
    env.storage().instance().set(&Self::MAP_KEY, map);
}
```

**Descripci√≥n:**\
Almacena el mapa proporcionado en el storage del contrato usando la clave `MAP_KEY`.

**Mecanismo:**

* Se guarda el `Map` en el storage para persistir los cambios.

***

8Ô∏è‚É£ **add\_map\_entry**

```rust
pub fn add_map_entry(env: Env, key: Symbol, value: String) {
    let mut my_map = Self::get_map(&env);
    my_map.set(key, value);
    Self::set_map(&env, &my_map);
}
```

**Descripci√≥n:**\
Agrega una entrada al mapa, utilizando una clave (`Symbol`) y su valor asociado (`String`).

**Mecanismo:**

* Recupera el mapa actual desde el storage.
* Utiliza el m√©todo `set` del `Map` para agregar la nueva entrada.
* Actualiza el storage con el mapa modificado.

***

9Ô∏è‚É£ **get\_map\_value**

```rust
pub fn get_map_value(env: Env, key: Symbol) -> Option<String> {
    let my_map = Self::get_map(&env);
    my_map.get(key)
}
```

**Descripci√≥n:**\
Obtiene el valor asociado a la clave especificada en el mapa.\
Retorna `Some(valor)` si existe o `None` si la clave no se encuentra.

**Mecanismo:**

* Recupera el mapa desde el storage.
* Utiliza `get` para buscar el valor asociado a la clave dada.

***

üîü **remove\_map\_entry**

```rust
pub fn remove_map_entry(env: Env, key: Symbol) -> Option<()> {
    let env_ref = &env;
    let mut my_map = Self::get_map(env_ref);
    if my_map.remove(key).is_some() {
        Self::set_map(&env, &my_map);
        Some(())
    } else {
        None
    }
}
```

**Descripci√≥n:**\
Elimina la entrada del mapa correspondiente a la clave especificada.\
Retorna `Some(())` si la operaci√≥n fue exitosa o `None` si la clave no exist√≠a en el mapa.

**Mecanismo:**

* Recupera el mapa actual desde el storage.
* Utiliza el m√©todo `remove` para eliminar la entrada asociada a la clave.
* Si se elimina, actualiza el storage con el mapa modificado mediante `set_map`.

***

üìå **Resumen General**\
Este contrato inteligente demuestra c√≥mo manejar estructuras de datos din√°micas en Soroban utilizando `Vec` y `Map` para gestionar colecciones de elementos de manera persistente en el storage.\
Permite:

* **Manipulaci√≥n de Vectores (Vec):**\
  Agregar, obtener y eliminar elementos del vector almacenado.
* **Manipulaci√≥n de Mapas (Map):**\
  Agregar, recuperar y eliminar entradas del mapa almacenado.

**Compilaci√≥n del contrato**

Ejecutamos lo siguiente:

```bash
Stellar contract build
```

**Despliegue del contrato**

Para Mac y Linux el salto de l√≠nea es con el car√°cter " **\\**" y en Windows con el car√°cter " **¬¥** "

Reemplaze el simbolo \* por el respectivo car√°cter de salto de linea a su sistema operativo.

```bash
stellar contract deploy *
  --wasm target/wasm32-unknown-unknown/release/vecmap.wasm *
  --source <Identity> *
  --network testnet *
  --alias option
```

<figure><img src="../../.gitbook/assets/image (10).png" alt=""><figcaption><p>Ejecuci√≥n de prueba</p></figcaption></figure>

**Pruebas del contrato**

Para **Linux y Mac** el salto de l√≠nea de la instrucci√≥n es con el car√°cter " \ " para **Windows** con el car√°cter " \` "

**Funci√≥n add\_vec:**

```bash
stellar contract invoke *
--id <CONTRACT_ID> *
--source <Identity> *
--network testnet *
-- *
add_vec *
--value "Hello üåé"
```

<figure><img src="../../.gitbook/assets/image (11).png" alt=""><figcaption><p>Ejecuci√≥n de prueba</p></figcaption></figure>

**Funci√≥n get\_vec\_element:**

```bash
stellar contract invoke *
--id <CONTRACT_ID> *
--source <Identity> *
--network testnet *
-- *
get_vec_element *
--index 0
```

<figure><img src="../../.gitbook/assets/image (12).png" alt=""><figcaption><p>Ejecuci√≥n de prueba</p></figcaption></figure>

**Funci√≥n remove\_vec\_element:**

```bash
stellar contract invoke *
--id <CONTRACT_ID> *
--source <Identity> *
--network testnet *
-- *
remove_vec_element *
--index 0
```

<figure><img src="../../.gitbook/assets/image (13).png" alt=""><figcaption><p>Ejecuci√≥n de prueba</p></figcaption></figure>

**Funci√≥n add\_map\_entry:**

```bash
stellar contract invoke *
--id <CONTRACT_ID> *
--source <Identity> *
--network testnet *
-- *
add_map_entry *
--key "key1" *
--value "hola que m√°s?"
```

<figure><img src="../../.gitbook/assets/image (14).png" alt=""><figcaption><p>Ejecuci√≥n de prueba</p></figcaption></figure>

**Funci√≥n get\_map\_value:**

```bash
stellar contract invoke *
--id <CONTRACT_ID> *
--source <Identity> *
--network testnet *
-- *
get_map_value *
--key "key1"
```

<figure><img src="../../.gitbook/assets/image (15).png" alt=""><figcaption><p>Ejecuci√≥n de prueba</p></figcaption></figure>

**Funci√≥n remove\_map\_entry:**

```bash
stellar contract invoke *
--id <CONTRACT_ID> *
--source <Identity> *
--network testnet *
-- *
remove_map_entry *
--key "key1"
```

<figure><img src="../../.gitbook/assets/image (6) (1).png" alt=""><figcaption><p>Ejecuci√≥n de prueba</p></figcaption></figure>
